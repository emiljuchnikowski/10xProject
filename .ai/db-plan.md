# Database Schema Plan — 10x-cards (PostgreSQL + Supabase)

This schema is designed for Supabase (PostgreSQL), aligning with the PRD and session decisions: integer PKs, audit logs for flashcard edits/deletions, dedicated linking for learning sessions, and explicit flashcard versioning. RLS policies restrict access to each user’s data.

1. Lista tabel z ich kolumnami, typami danych i ograniczeniami

- Table: profiles
  - id: integer, primary key, generated by identity
  - user_id: uuid, not null, unique, references auth.users(id) on delete cascade
  - display_name: text, null
  - created_at: timestamptz, not null, default now()

- Table: decks
  - id: integer, primary key, generated by identity
  - user_id: uuid, not null, references auth.users(id) on delete cascade
  - name: text, not null
  - description: text, null
  - is_default: boolean, not null, default false
  - created_at: timestamptz, not null, default now()
  - updated_at: timestamptz, not null, default now()
  - Constraints:
    - unique (user_id, name)

- Table: flashcards
  - id: integer, primary key, generated by identity
  - user_id: uuid, not null, references auth.users(id) on delete cascade
  - deck_id: integer, not null, references decks(id) on delete cascade
  - front: text, not null
  - back: text, not null
  - source: text, not null, default 'manual', check (source in ('manual','ai'))
  - accepted_from_suggestion_id: integer, null, references ai_suggestions(id) on delete set null
  - created_at: timestamptz, not null, default now()
  - updated_at: timestamptz, not null, default now()

- Table: flashcard_versions
  - id: integer, primary key, generated by identity
  - flashcard_id: integer, not null, references flashcards(id) on delete cascade
  - version_number: integer, not null
  - front: text, not null
  - back: text, not null
  - changed_by: uuid, null, references auth.users(id) on delete set null
  - change_reason: text, null
  - reverted_from_version_number: integer, null
  - created_at: timestamptz, not null, default now()
  - Constraints:
    - unique (flashcard_id, version_number)

- Table: audit_flashcards
  - id: integer, primary key, generated by identity
  - flashcard_id: integer, not null, references flashcards(id) on delete cascade
  - user_id: uuid, null, references auth.users(id) on delete set null
  - action: text, not null, check (action in ('update','delete'))
  - before: jsonb, null   // snapshot before change (for delete/update)
  - after: jsonb, null    // snapshot after change (for update)
  - reason: text, null
  - source: text, null    // e.g., 'ui','api'
  - ip: inet, null
  - user_agent: text, null
  - created_at: timestamptz, not null, default now()

- Table: ai_generation_requests
  - id: integer, primary key, generated by identity
  - user_id: uuid, not null, references auth.users(id) on delete cascade
  - input_text: text, not null
  - model: text, null           // model identifier used
  - suggestion_count: integer, null
  - prompt_tokens: integer, null
  - completion_tokens: integer, null
  - status: text, not null, default 'pending', check (status in ('pending','succeeded','failed'))
  - error: text, null
  - created_at: timestamptz, not null, default now()
  - Constraints:
    - check (char_length(input_text) between 1000 and 10000)

- Table: ai_suggestions
  - id: integer, primary key, generated by identity
  - generation_id: integer, not null, references ai_generation_requests(id) on delete cascade
  - user_id: uuid, not null, references auth.users(id) on delete cascade
  - front: text, not null
  - back: text, not null
  - accepted: boolean, not null, default false
  - accepted_at: timestamptz, null
  - converted_flashcard_id: integer, null, references flashcards(id) on delete set null
  - created_at: timestamptz, not null, default now()

- Table: learning_sessions
  - id: integer, primary key, generated by identity
  - user_id: uuid, not null, references auth.users(id) on delete cascade
  - deck_id: integer, null, references decks(id) on delete set null
  - algorithm: text, not null, default 'sm2'
  - started_at: timestamptz, not null, default now()
  - ended_at: timestamptz, null
  - notes: text, null

- Table: session_flashcards
  - id: integer, primary key, generated by identity
  - session_id: integer, not null, references learning_sessions(id) on delete cascade
  - flashcard_id: integer, not null, references flashcards(id) on delete cascade
  - order_index: integer, not null, default 0
  - shown_at: timestamptz, null
  - answered_at: timestamptz, null
  - result: smallint, null  // rating/quality per algorithm (e.g., 0-5)
  - interval_days: integer, null
  - ease_factor: real, null
  - repetitions: integer, null
  - next_due_at: timestamptz, null
  - notes: text, null
  - created_at: timestamptz, not null, default now()
  - Constraints:
    - unique (session_id, flashcard_id)

2. Relacje między tabelami

- profiles (1) — (1) auth.users via profiles.user_id (unique)
- users (auth.users) (1) — (N) decks via decks.user_id
- users (auth.users) (1) — (N) flashcards via flashcards.user_id
- decks (1) — (N) flashcards via flashcards.deck_id
- flashcards (1) — (N) flashcard_versions via flashcard_versions.flashcard_id
- users (auth.users) (1) — (N) ai_generation_requests via ai_generation_requests.user_id
- ai_generation_requests (1) — (N) ai_suggestions via ai_suggestions.generation_id
- users (auth.users) (1) — (N) ai_suggestions via ai_suggestions.user_id
- ai_suggestions (1) — (0..1) flashcards via flashcards.accepted_from_suggestion_id and ai_suggestions.converted_flashcard_id
- users (auth.users) (1) — (N) learning_sessions via learning_sessions.user_id
- decks (1) — (N) learning_sessions via learning_sessions.deck_id (optional)
- learning_sessions (1) — (N) session_flashcards via session_flashcards.session_id
- flashcards (1) — (N) session_flashcards via session_flashcards.flashcard_id
- flashcards (1) — (N) audit_flashcards via audit_flashcards.flashcard_id
- users (auth.users) (1) — (N) audit_flashcards via audit_flashcards.user_id

3. Indeksy

- profiles: unique index on (user_id)
- decks: index on (user_id); unique(user_id, name)
- flashcards:
  - index on (user_id)
  - index on (deck_id)
  - index on (accepted_from_suggestion_id)
  - optional GIN index on (to_tsvector('simple', front || ' ' || back)) for future search
- flashcard_versions: index on (flashcard_id), unique(flashcard_id, version_number)
- audit_flashcards: index on (flashcard_id), index on (user_id), index on (action), index on (created_at desc)
- ai_generation_requests: index on (user_id), index on (status), index on (created_at desc)
- ai_suggestions: index on (generation_id), index on (user_id), index on (accepted), index on (created_at desc)
- learning_sessions: index on (user_id), index on (deck_id), index on (started_at desc)
- session_flashcards: index on (session_id), index on (flashcard_id), unique(session_id, flashcard_id), index on (next_due_at)

4. Zasady PostgreSQL (RLS)

All tables with user-owned data have RLS enabled. Example policy names provided; adjust for Supabase migration style.

- profiles
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (user_id = auth.uid())

- decks
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (user_id = auth.uid())

- flashcards
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (user_id = auth.uid())

- flashcard_versions
  - Enable RLS
  - SELECT: using (exists (select 1 from flashcards f where f.id = flashcard_id and f.user_id = auth.uid()))
  - INSERT: with check (exists (select 1 from flashcards f where f.id = flashcard_id and f.user_id = auth.uid()))
  - UPDATE/DELETE: same as SELECT

- audit_flashcards
  - Enable RLS
  - SELECT: using (exists (select 1 from flashcards f where f.id = flashcard_id and f.user_id = auth.uid()))
  - INSERT: with check (exists (select 1 from flashcards f where f.id = flashcard_id and f.user_id = auth.uid()))
  - UPDATE/DELETE: deny (no policy)

- ai_generation_requests
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (user_id = auth.uid())

- ai_suggestions
  - Enable RLS
  - SELECT/UPDATE/DELETE: using (user_id = auth.uid())
  - INSERT: with check (
      exists (
        select 1 from ai_generation_requests g
        where g.id = generation_id and g.user_id = auth.uid()
      ) and user_id = auth.uid()
    )

- learning_sessions
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (user_id = auth.uid())

- session_flashcards
  - Enable RLS
  - SELECT/INSERT/UPDATE/DELETE: using (
      exists (
        select 1 from learning_sessions s
        where s.id = session_id and s.user_id = auth.uid()
      )
    )

5. Dodatkowe uwagi

- PK Strategy: All application tables use integer primary keys generated by identity; user linkage uses auth.users(id) UUIDs via user_id columns.
- Deletion semantics: PRD requires permanent deletion; audit_flashcards captures delete events (with before snapshot) prior to row deletion (application-level responsibility).
- Versioning: On each update to flashcards, insert into flashcard_versions with incremented version_number. Optionally set reverted_from_version_number when rolling back.
- AI generation stats: Use ai_generation_requests and ai_suggestions to aggregate how many suggestions were generated and how many were accepted/converted to flashcards.
- Learning algorithm fields: session_flashcards stores generic spaced repetition parameters (result, interval_days, ease_factor, repetitions, next_due_at) to remain compatible with common algorithms (e.g., SM-2). This supports scheduling and future analytics.
- Indexing for scale: The provided indices cover common filters (by user_id, deck_id, status, timestamps) and scheduling (next_due_at). Add full-text search indices later if needed.
- Constraints vs triggers: No triggers are required per planning notes. Timestamps use defaults; the application controls additional lifecycle rules.
- Cascade rules: FKs to auth.users use ON DELETE CASCADE to satisfy account deletion requests cascading to user-owned content.
